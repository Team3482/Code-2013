// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package robot.core.subsystems;
import com.sun.squawk.util.Arrays;
import edu.wpi.first.wpilibj.camera.AxisCamera;
import edu.wpi.first.wpilibj.camera.AxisCamera.*;
import edu.wpi.first.wpilibj.camera.AxisCameraException;
import edu.wpi.first.wpilibj.Timer;
import robot.core.commands.*;
import edu.wpi.first.wpilibj.image.*;
import edu.wpi.first.wpilibj.command.Subsystem;

import java.util.*;
/**
 * The Camera subsystem provides vision processing functionality
 * for the Axis Camera
 */
public class Camera extends Subsystem {
    
    // Camera setting constants
    static final int BRIGHTNESS  = 50;
    static final int COLOR_LEVEL = 50;
    static final int COMPRESSION = 30;
    static final int MAX_FPS     = 24;
    static final ExposurePriorityT EXPOSURE_PRIORITY = ExposurePriorityT.none;
    static final ResolutionT       RESOLUTION        = ResolutionT.k320x240;
    static final RotationT         ROTATION          = RotationT.k0;
    static final WhiteBalanceT     WHITE_BALANCE     = WhiteBalanceT.fixedIndoor;
    static final String IPAdress = "10.34.82.11";
    
    // TODO: find constants for *our* ring light
    // Pixel filtering constants for the green ring light in the sample images(HSV)
    static final int HUE_LOW         = 96;
    static final int HUE_HIGH        = 114;
    static final int SATURATION_LOW  = 148;
    static final int SATURATION_HIGH = 255;
    static final int VALUE_LOW       = 84;
    static final int VALUE_HIGH      = 162;
    
    static CriteriaCollection cc = new CriteriaCollection();
    
    // Area ranges
    static final float   AREA_LOW      = 500;
    static final float   AREA_HIGH     = 65535 ;
    static final boolean OUTSIDE_RANGE = false;
    
    // Max/Min edge scores
    final int XMAXSIZE = 24;
    final int XMINSIZE = 24;
    final int YMAXSIZE = 24;
    final int YMINSIZE = 48;
    static final double xMax[] = { 1,  1,   1,   1,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,   1,   1,   1,   1};
    static final double xMin[] = {.4, .6,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1,  .1, 0.6,   0};
    static final double yMax[] = { 1,  1,   1,   1,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,  .5,   1,   1,   1,   1};
    static final double yMin[] = {.4, .6, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .6, 0};
    
    public class Scores {
        double rectangularity;
        double aspectRatioMiddle;
        double aspectRatioOuter;
        double xEdge;
        double yEdge;
        
        public double getCompositeScore() {
            double aspectRatio = aspectRatioMiddle > aspectRatioOuter ? aspectRatioMiddle : aspectRatioOuter;
            return (rectangularity + aspectRatio + xEdge + yEdge) / 400;
        }
    }
    
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public Scores[] score(ColorImage img) throws NIVisionException {
        // TODO: Add waits before looping again (preferably until a new image is available)
        // Adds particle area to the CriteriaCollection object for calculating rectangularity score
        cc.addCriteria(NIVision.MeasurementType.IMAQ_MT_AREA, AREA_LOW, AREA_HIGH, OUTSIDE_RANGE);
        BinaryImage threshold, convexHull, filtered;
        boolean connectivity8 = false;
        
        threshold = img.thresholdHSV(HUE_LOW, HUE_HIGH, SATURATION_LOW,
            SATURATION_HIGH, VALUE_LOW, VALUE_HIGH);
        convexHull = threshold.convexHull(connectivity8);
        filtered = convexHull.particleFilter(cc);
        
        Scores[] scores = new Scores[filtered.getNumberParticles()];
        for(int i = 0; i < scores.length; i++) {
            ParticleAnalysisReport report = filtered.getParticleAnalysisReport(i);
            
            scores[i].rectangularity    = scoreRectangularity(report);
            scores[i].aspectRatioMiddle = scoreAspectRatio(report, true); 
            scores[i].aspectRatioOuter  = scoreAspectRatio(report, false);
            scores[i].xEdge             = scoreXEdge(filtered, report);
            scores[i].yEdge             = scoreYEdge(filtered, report);
        }
        threshold.free();
        convexHull.free();
        filtered.free();
        return scores;
    }
    
    // Scoring different aspects of particles
    private double scoreRectangularity(ParticleAnalysisReport report) {
        double boundingRectArea;
        
        if((boundingRectArea = report.boundingRectHeight*report.boundingRectWidth) != 0) {
            return 100*report.particleArea/boundingRectArea;
        } else {
            return 0;
        }
    }
    private double scoreAspectRatio(ParticleAnalysisReport report, boolean middle) {
        double aspectRatio = report.boundingRectWidth/report.boundingRectHeight;
        double idealAspectRatio = middle ? (62/29) : (62/20);
        return Math.max(0, 100 * (1 - Math.abs(1 - aspectRatio/idealAspectRatio)));
    }
    private double scoreXEdge(BinaryImage img, ParticleAnalysisReport report) throws NIVisionException {
        LinearAverages avgs;
        float[] colAvgs;
        int c = 0;
        
        NIVision.Rect rect = new NIVision.Rect(report.boundingRectTop, report.boundingRectLeft,
                report.boundingRectHeight, report.boundingRectWidth);
        avgs = NIVision.getLinearAverages(img.image,
                LinearAverages.LinearAveragesMode.IMAQ_COLUMN_AVERAGES, rect);
        colAvgs = avgs.getColumnAverages();
        
        for(int i = 0; i < colAvgs.length; i ++) {
            if(xMin[(i*(XMAXSIZE-1)/colAvgs.length)] <= colAvgs[i] &&
                    xMax[(i*(XMAXSIZE-1)/colAvgs.length)] >= colAvgs[i]) {
                c++;
            }
        }
        
        return 100 * c/(colAvgs.length);
    }
    private double scoreYEdge(BinaryImage img, ParticleAnalysisReport report) throws NIVisionException {
        LinearAverages avgs;
        float[] rowAvgs;
        int c = 0;
        
        NIVision.Rect rect = new NIVision.Rect(report.boundingRectTop, report.boundingRectLeft,
                report.boundingRectHeight, report.boundingRectWidth);
        avgs = NIVision.getLinearAverages(img.image,
                LinearAverages.LinearAveragesMode.IMAQ_ROW_AVERAGES, rect);
        rowAvgs = avgs.getRowAverages();
        
        for(int i = 0; i < rowAvgs.length; i++) {
            if(yMin[(i*(YMINSIZE-1)/rowAvgs.length)] <= rowAvgs[i] &&
                    yMax[(i*(YMAXSIZE-1)/rowAvgs.length)] >= rowAvgs[i]) {
                c++;
            }
        }
        
        return 100 * c/(rowAvgs.length);
    }

    public int[] getTargets(Scores[] scores) {
        double[] compositeScores = new double[scores.length];
        for(int i = 0; i < scores.length; i++) {
            compositeScores[i] = scores[i].getCompositeScore();
        }
        return new int[20];
    }
    
    // Retrieving images from the camera
    public boolean freshImage() {
        return AxisCamera.getInstance(IPAdress).freshImage();
    }
    public ColorImage getImage() throws AxisCameraException, NIVisionException {
        return AxisCamera.getInstance(IPAdress).getImage();
    }

    // Method to configure camera settings
    public void configureCamera() {
        AxisCamera c = AxisCamera.getInstance();
        c.writeBrightness(BRIGHTNESS);
        c.writeColorLevel(COLOR_LEVEL);
        c.writeCompression(COMPRESSION);
        c.writeExposurePriority(EXPOSURE_PRIORITY);
        c.writeMaxFPS(MAX_FPS);
        c.writeResolution(RESOLUTION);
        c.writeRotation(ROTATION);
        c.writeWhiteBalance(WHITE_BALANCE);

        c.writeExposureControl(ExposureT.automatic);
        Timer.delay(5);
        c.writeExposureControl(ExposureT.hold);
    }
}
